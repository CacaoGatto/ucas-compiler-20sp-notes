# 第一章 编译概论

[toc]

## 编译的概念

- 从**源语言（或某种低层语言）**表示的算法到面向硬件的**目标语言**表示的算法的一个**等价变换**。
  - 一般程序设计语言包括语法、语义和语用。变换要求满足语义的等价性。（注意：不一定满足数学上的实时等价）
  - 翻译器：产生的机器语言目标程序更快。（不用逐个语句执行）
  - 解释器：错误诊断效果更好。（因为逐个语句地执行源程序）
  - （混合编译器取两者所长，如Java语言处理器）
  - 汇编语言：复用各架构的汇编器；容易输出和调试。

## 编译的流程和编译器的结构

### 编译过程

- 将源程序映射为语义等价的可执行的目标程序，并进行优化。为了**便于移植**，可分为两部分（优化同时包括两部分，也同时包括对源程序和目标程序的优化）
- 分析：（前端）
  - 把程序分解为多个组成要素，加上语法结构，创建中间表示。
  - 检测（全部）语法和（部分）语义上的不一致性，报错。
  - 把符号表和中间表示一起传递给综合部分。
- 综合：（后端）
  - 根据中间表示和符号表构造目标程序。

### 标准编译流程

- 词法分析程序：字符流->记号流
  - 单词是记号的实例（给字符序列标记逻辑）：<token-name, attribute-value>
  - 同时完成一些可行操作，如填符号表。	
- 语法分析（解析）程序：记号流->语法短语
  - 得到分析树或语法树。后者更简洁，是后续工作的依托。
  - 语法树的内部节点表示一个计算，叶子节点表示参与运算的记号，层次表征了计算的优先次序。
- 语义分析程序：检查语义正确性
  - 静态语义：执行前可以确定而不易被语法表示的特征。也即语义分析的内容。
  - 静态语义包括声明和类型检查（算符运算对象的匹配）等。可能增加强制类型转换。
  - 数据类型等额外信息作为属性，添加到语法树中。
- 中间代码生成：
  - 对于一个源程序到目标代码的过程，一个编译器可能一个或多个中间表示。
  - 不同编译器选择的中间代码可能不同。（为了易于生成并翻译为目标机器语言）
  - 三地址代码是一种常用的底层表示。
    - 每个指令具有三个运算分量
    - 每条复制右部只能有一个运算符，指令次序决定完成顺序
    - 编译器生成临时命名存放计算结果
    - 部分指令运算对象可小于3
- （机器无关）代码优化：改变中间代码
  - 使用简单的中间代码生成算法，在进行代码优化。
  - 尽可能在编译中完成优化。
  - 不同编译器的优化存在很大差异。
- 代码生成器：
  - 将中间表示映射到目标语言，生成目标代码；目标代码为机器代码时，变量映射为存储位置。
  - 目标机器的特性是主要影响因素。
  - 寄存器的合理使用是重要问题。
- 目标代码优化器：改进目标代码
  - 选择编址模式
  - 慢速（多拍）指令换为快速（少拍）指令
  - 删除冗余代码
  - 寄存器优化
  - 软流水
- 符号表的管理
- 将多个阶段组合成pass（趟/遍）：每趟读入一个文件，并产生一个输出文件

## 程序设计语言的发展历程

- 起始阶段->大型机时代->PC机时代->网络时代
- 程序设计语言的定义
  - 语法：合法程序的构成规则
  - 语义：各语法成分的意义
    - 静态程序语义：编译时可确定
    - 动态程序语义：执行时才确定
  - 语用：符号与使用者间的关系，如变量的物理意义

## 程序设计语言与编译器相互影响

- 编译技术支持新需求
- 优化效果是语言普及的重要推动原因
- 编译技术发展可以简化、改良语言设计

## 构建编译器的相关科学

### 开发的基本考虑

- 数学建模
  - 例如图着色的寄存器分配算法
- 保持语义
- 优化程序

### 代码优化

- 优化的目标：生成更高质量的代码
    1. 性能
    2. 代码大小（如：嵌入式）
    3. 功耗
- 优化应尽可能不对调试等方面产生严重负面影响
- 结合应用拓展、机器结构
    1. 并行优化
    2. 即时优化
    3. 新硬件和智能处理器
- 效果应能经受检验
    1. 传统优化基于数学基础
    2. 基于统计学基础的应用和非精确计算
- 很多优化问题不可判定

### 优化实现中的考虑

- 优化不能改变编译程序的含义
  - 但是理论上很难证明优化完全无错
- 优化的效果不能只对个别输入程序有效
  - 对不同程序具有普适性
  - 对同一程序的不同输入也不应有较大波动
- 控制优化的时间开销
  - 支持快速开发和调试周期
- 所需工程方面的工作可管理

## 编译技术的应用

- 实现高级程序设计语言
- 针对体系结构优化、设计
  - 如RISC和专用架构
- 程序翻译
  - 二进制翻译
  - 应键综合
  - 数据查询解释器
  - 编译后模拟
- 软件生产率工具
  - 安全架构
  - 错误检测和定位

## 程序设计语言基础

### 静态和动态的区别

#### 静态策略

- 支持（静态）编译时刻决定某个问题的策略
- 如：C语言中的变量名、变量类型

#### 动态策略

- 只允许在运行程序时做出决定的策略
- 如：C语言中变量（非常量）的值

#### 声明的作用域

> 变量的一个声明的作用域，是指程序中对该变量的引用，都指向这个声明的区域
> 两种不同的作用域主要影响当前执行过程中未声明对象的解释

##### 动态作用域

> 动态作用域通过过程调用实例执行轨迹的包含关系解释

- 各种函数语言
- 作用域策略依赖于只有在程序执行时才知道的若干因素
  - 采用最近祖先节点的声明
- C语言的宏解析**不是**动态作用域策略

##### 静态作用域

> 静态作用域根据源程序中嵌套声明的位置关系进行解释

- 如C语言等多数语言
- 根据声明上下文的程序结构（如C）决定作用域限制
- C++和Java等语言引入了控制作用域的关键字

###### static关键字

- Java中：成为类变量，无论创建多少类对象，只有一个拷贝
- C中：放在静态数据区，也只有一个拷贝。可实现多次活动中的传递，但不是参数传递

### 环境与状态

- 环境
  - 函数名到存储位置的映射
  - 函数调用的发生会引起环境的改变
- 状态
  - 内存位置到值的映射
  - 赋值语句会引起状态的改变
- 环境和状态的两级映射**通常**是动态的
  - C的全局变量可在代码生成时直接分配存储位置，静态绑定名字到位置的映射
  - C的常量声明可以绑定位置到值的映射

### 块结构

#### 标识符

- 一个（通常）由字母和数字构成的字符串
- 标记一个实体（数据对象/过程/类/类型）
- 标识符都是名字
- 名字可以不是标识符，如`x.y`（称为受限名字）

#### 变量

- 指向存储结构中某个特定位置
- 标识符可以被多次声明，每次声明引入一个新变量
  - 某些语言（Python警告）允许多次声明以完善变量属性。此时不引入新变量
  - 常见语言中不同作用于的多次声明指明不同变量

#### 可被调用的子程序（过程/函数/方法）

- 函数有返回值，过程没有
- C中只有函数，Java中只有方法

### C语言的静态作用域和块结构

#### C的静态作用域

- 顶层变量和函数声明的序列组成全局作用域
- 函数内部的局部变量和参数组成局部作用域
- 声明从声明位置开始起作用，可能被同名声明的局部作用域覆盖

#### C的块语法

- 块是一种语句
- 块包含一个声明的序列
- 允许嵌套

### 显式访问控制

- 类、结构等语言规范对象引入新作用域
- 通过关键字指明合法访问属性
- 名字可以被声明所在作用域外的的程序访问

### 声明和定义

- 声明
  - 给出名字的属性，如类型、作用域等
  - 过程等对象声明可只暂不给出代码体
- 定义
  - 给出名字对象的值
  - 过程名的定义是给出对应代码

### 参数传递

- 过程调用者可以通过非局部名字、参数和返回值与过程交换信息
- 形参和实参对表达式所表达内容解释不同

#### 值调用

- 形参作为局部名，存储单元在被调用过程的活动记录中
- 调用者计算实参，把右值放在形参的存储单元中，传递给被调用过程
- 形参运算不影响调用者活动记录的值
- 被调用过程可通过非局部名字/显式传递的指针影响调用者
  - 即使如此，调用者传递的参数（地址值）依然不被改变
- C和Pascal均支持

#### 引用调用（地址调用/位置调用）

- 调用者将参数左值传递给被调用过程（改变实参）
- 若实参是有左值的名字或表达式，则传递左值本身
- 若实参是无左值的表达式，则把值计算保存到新的存储单元，然后传递单元的地址
- 是数组及Pascal中var参数的主要传递方式

#### 换名调用

- 仅在理论上/历史上存在。
- 把过程看成宏，文字替代后用实参代替形参
- In-lining是一种类似技术

### 别名

> 在同一代码段中，以多个名字访问同一存储位置

- 可能引发错误
- 影响编译优化结果
- 引入别名的方式包括
  - 两个形参结合的实参是同一变量
  - 形参与全局量别名
  - C中union关键字引入别名
  - 指针的指向引入别名
